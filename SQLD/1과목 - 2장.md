# 데이터 모델과 SQL

## 정규화

>[!note] 정규화란?
데이터베이스의 이상현상 발생을 방지하기 위해, 
데이터의 중복을 최소화하면서 테이블을 보다 잘 조직된 상태로 분해하는 과정
>
> 정규화의 결과 : 데이터의 입력, 수정, 삭제 성능 향상
> 많은 조인이 발생하면서 조회성능이 하락할 수 있으며, 이때 조회성능을 올리기 위해 반정규화 수행

>[!warning] 이상현상
**삽입 이상** : 테이블에 데이터를 삽입할 때 의도하지 않은 정보까지 삽입해야 하는 현상
**갱신 이상** : 중복 저장되어 있는 데이터 중 하나만 갱신하고 다른 하나를 갱신하지 않을 때 나타나는 데이터의 불일치 현상
**삭제 이상** : 테이블의 특정 데이터를 삭제할 때 의도하지 않은 정보까지 삭제되는 현상

| **정규화 절차** | **설명**                                                                |
| ---------- | --------------------------------------------------------------------- |
| 제1정규화      | 릴레이션의 속성값이 모두 원자값(Atomic Value)만으로 구성<br>- 중복값을 제거한다.<br>- 기본키를 설정한다. |
| 제2정규화      | 기본키가 2개 이상의 속성으로 이루어진 경우 부분 함수종속성을 제거                                 |
| 제3정규화      | 기본키를 제외한 컬럼 간의 종속성을 제거 / 이행 함수종속성을 제거                                 |
| BCNF       | 기본키를 제외하고 후보키가 있는 경우 후보키가 기본키를 종속시키면 분해                               |

### 제 1 정규형
**모든 속성이 하나의 속성값만을 가지고 있으면서 유사한 속성이 반복되지 않는 상태**
하나의 속성이 여러 속성값을 가질 때나 하나의 테이블에 유사한 속성이 반복될 때 이를 별도의 테이블로 분리

### 제 2 정규형
**부분 함수종속성이 제거된 상태**
- 부분 함수종속성 : 주식별자가 두 개 이상으로 구성된 복합식별자인 경우, 일반 속성이 주식별자의 <U>일부에만</U> 종속성을 가짐
현재 테이블과 관련성이 적은 컬럼을 다른 테이블로 빼는 방식으로 실행된다.
> 주식별자가 단일식별자일 때에는 이미 그 자체가 이미 제 2정규형이므로 제2정규화가 필요 없다. 

### 제 3 정규형
**이행 함수종속성이 제거된 상태**
식별자가 아닌 일반 컬럼에 종속된 컬럼을 다른 테이블로 빼는 방식으로 실행된다.
-이행 함수종속성 : 주식별자가 아닌 일반 속성 간에 함수종속성이 존재하는 것

---
## 관계와 조인의 이해

>[!note] 조인(Join)이란?
>두 개의 테이블을 공통의 식별자를 통해 데이터를 조회할 수 있도록 하나의 테이블로 합치는 것

데이터의 정합성과 조회성능 간에는 **트레이드 오프 관계가 성립**
 `트레이드 오프 관계 : 두 개의 속성이 서로 상충하는 관계, 하나가 증가하면 다른 하나는 감소하는 관계
➡️ 모델링 과정에서 시스템 요구사항에 맞게 적절한 정합성 수준을 결정할 필요성


**성능 데이터 모델링 절차**
1. 데이터 모델링 시 정규화를 정확하게 수행
2. 데이터베이스 용량 산정
3. 데이터베이스 내 발생하는 트랜젝션의 유형 파악
4. 용량과 트랜젝션의 유형에 따라 반정규화 수행
5. 이력모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등 수행
6. 성능 관점에서의 데이터 모델 검증

### 반정규화가 필요한 상황

> [!note] 반정규화란?
> 정규화와 반대로 데이터의 중복을 허용하거나 데이터를 그룹핑하여 조회성능을 향상시키는 것
> 데이터베이스의 정합성을 저하시켜 문제를 발생시킬 수 있으므로 대안을 충분히 검토한 후에 수행해야 함

**반정규화 수행 절차
1. 반정규화 대상 조사 : 범위처리 빈도수 조사, 통계성 프로세스 조사, 테이블 조인 개수 등 반정규화 대상 조사
2. 다른 방법 검토 : 뷰 테이블 생성, 인덱스 조정, 클러스터링 적용, 응용 애플리케이션에서의 처리 등 대안 검토
3. 반정규화 적용 : 테이블 반정규화, 컬럼 반정규화, 관계 반정규화 등 반정규화 수행

### 테이블 반정규화
#### 테이블 병합
조인의 발생 빈도가 높아 아예 여러 테이블을 하나로 합치는 것이 유리할 때에는 테이블을 병합
- **1:1 관계 테이블 병합**
- **1:M 관계 테이블 병합**
- **슈퍼타입/서브타입 관계 테이블 병합**
	- One to One Type : 슈퍼타입, 서브타입 테이블들을 각각 개별 테이블로 구성
	- Plus Type : 각각의 서브타입에 슈퍼타입을 합하여 슈퍼타입+서브타입 테이블로 구성
	- Single Type (All in One 타입) : 전체를 하나의 테이블로 통합

#### 테이블 분할
테이블의 **특정 속성들에 대해서만 집중적으로 접근하는 경우** 별도의 테이블로 분할
이를 통해 접근 빈도, 잠김, 경합 현상이 감소하는 효과
분할된 테이블의 속성을 . 한번에 조회할 때에는 유니온, 조인을 사용하게 되므로 성능하락 발생

##### 수직분할
테이블에서 수직으로 컬럼을 쪼갠다고 해서 수직분할 
로우체이닝이 발생할 경우 우선적으로 고려해야 할 사항
특정 속성들에 대해서만 접근이 빈번할 때, 해당 속성들을 별도의 테이블로 분할하여 1:1 관계 생성
##### 수평분할(파티셔닝)
테이블에서 수평으로 로우를 쪼갠다고 해서 수평분할
속성의 값에 따라 구분하여 조회하는 경우(예를 들어, 연도별 조회) 
인스턴스들을 그룹핑하여 나누어질 수 있도록 분할
	`파티셔닝을 통해 분리된 테이블은 물리적으로는 여러 개의 테이블이지만 논리적으로는 스키마가 같은 하나의 테이블로 볼 수 있다.`

#### 테이블 추가
조회에 필요한 속성을 포함하는 새로운 테이블을 추가

**중복 테이블 추가** : 타 업무나 서버의 테이블과 동일한 구조의 테이블을 중복해서 추가
**통계 테이블 추가** : sum, avg 등 통계값에 해당하는 연산을 미리 계산하여 저장하는 별도의 테이블을 추가
**이력 테이블 추가** : 변경 이력 등 이력 데이터를 관리할 수 있는 테이블을 별도로 추가
**부분 테이블 추가** : 디스크 I/O를 줄이기 위해 하나의 테이블 내 특별히 자주 사용하는 속성들만 모아서 새로운 테이블로 추가

### 컬럼 반정규화
**중복 컬럼 추가** : 조인을 감소시키기 위해 자주 사용하는 컬럼을 중복 추가
**파생 컬럼 추가** : 계산값을 별도의 칼럼으로 미리 추가하는 기법으로, 계산에 의한 부하 발생을 줄이기 위해 수행
**이력 테이블 컬럼 추가** : 이력 테이블에 조회 조건에 해당하는 기능성 칼럼을 추가, 대량의 데이터를 처리할 때 조회성능 저하 예방 목적
**PK에 의한 컬럼 추가** : 복합적인 의미를 가지는 PK를 단일 속성으로 구성했을 때, PK를 파싱해서 추가적인 내용을 조회해야 하는 경우 성능 하락이 있을 수 있으므로 이를 일반 속성으로 추가
**응용 시스템 오동작을 위한 컬럼 추가** : 응용 시스템에서 데이터 처리 도중 오류가 발생한 경우 원래의 값을 복원하듯 오동작 처리를 위해 이전 데이터를 임시적으로 중복하여 보관하는 기법

### 관계 반정규화
여러 과계를 거쳐 다수의 조인을 통해 처리가 가능하지만, 이때 발생할 수 있는 성능 저하를 막기 위해 추가적으로 중복된 관계를 맺는 방법

---
## 모델이 표현하는 트랜젝션의 이해
### 트랜젝션의 개념
트랜젝션 : 데이터베이스에 데이터를 읽고 쓸 때, 한 번에 수행되어야 하는 논리적인 작업 단위

#### 트랜젝션의 특성

| 특성                   | 설명                                                                           |
| -------------------- | ---------------------------------------------------------------------------- |
| **원자성(Atomicity)**   | 하나의 트랜젝션으로 묶인 연산들은 'All or Nothing'이라는 개념으로<br>완전히 실행되거나 아니면 전혀 실행되지 않아야 한다. |
| **일관성(Consistency)** | 트랜젝션의 결과는 데이터베이스의 정합성을 깨지 않는다.<br>트랜젝션 이전에 데이터베이스에 오류가 없다면 트랜젝션 이후에도 오류가 없다. |
| **고립성(Isolation)**   | 트랜젝션은 독립적으로 수행되며 다른 트랜젝션이 실행 중간에 간섭하거나 영향을 미치지 않는다.                          |
| **영속성(Durability)**  | 트랜젝션의 결과는 데이터베이스에 영구적으로 저장되어 유지된다.                                           |
#### 트랜젝션의 격리 수준이 낮을 때의 문제점
| 문제점                     | 설명                                                                                        |
| ----------------------- | ----------------------------------------------------------------------------------------- |
| **Dirty Read**          | 트랜젝션에 의해 수정되었으나 아직 커밋이 되지 않은 상태에서,<br>다른 트랜젝션이 해당 데이터를 읽으면 발생하는 데이터의 불일치 현상               |
| **Non-Repeatable Read** | 한 트랜젝션 내에서 같은 쿼리를 두 번 실행할 때,<br>그 사이 다른 트래젝션이 값을 수정 혹은 삭제하면서 첫 번째와 두 번째 쿼리의 실행결과가 달라지는 현상 |
| **Phantom Read**        | 한 트랜젝션 내에서 같은 쿼리를 두 번 실행할 때,<br>그 사이 다른 트래젝션이 값을 삽입하면서 두 번째 쿼리에서 이전에 없던 레코드가 나타나는 현상      |


---
## Null 속성의 이해
### Null의 개념
아직 입력된 값이 없는 상태로, 아무런 값도 가지고 있지 않은 상태를 의미하는 표현
- Null 값은 'Null'이라는 문자열값과 다르다.
- Null 값은 공백과 다르다.
- Null 값은 수 0과 다르다.

단일행 연산 : Null 값과의 연산 수행 결과는 Null
다중행 연산 : Null 값을 제외하고 연산 수행

---
## 본질식별자 vs 인조식별자